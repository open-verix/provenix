üõ°Ô∏è Provenix

The Policy-Driven Software Supply Chain Orchestrator

Provenix is an intent-first security orchestrator that generates atomic, cryptographically bound evidence for software artifacts. It abstracts tools like Cosign, Syft, and Grype into a single, policy-centric workflow‚Äîwithout forcing users to learn or operate those tools directly.

Provenix observes and records. It does not silently enforce.

‚∏ª

Core Concept: Atomic Evidence

Atomic Evidence means:

All evidence (SBOM, vulnerability results, provenance) is generated in a single execution context and cryptographically bound to the exact artifact digest at the moment of attestation.

It does not mean that all checks must pass.
	‚Ä¢	Evidence may contain gaps
	‚Ä¢	External publishing may partially fail
	‚Ä¢	Integrity must never be broken

If atomicity is violated ‚Üí Provenix fails hard.

‚∏ª

Zero-Config First (MVP Philosophy)

Provenix is designed so that OSS maintainers can run it with zero configuration:

provenix generate <artifact>

No keys. No YAML. No CI glue code.

Important Design Choice

When no configuration file is provided:

Provenix automatically generates an in-memory default policy.

This is not only acceptable ‚Äî it is recommended.
	‚Ä¢	Users get safe, predictable behavior
	‚Ä¢	Defaults are explicit and documented
	‚Ä¢	Generated policy is shown in logs (--debug)

‚∏ª

Implicit Default Policy (Zero Config)

The following policies are implicitly applied when provenix.yaml is absent.

1. Identity Policy
	‚Ä¢	Strategy: Keyless (OIDC)
	‚Ä¢	Identity source:
	‚Ä¢	CI: GitHub Actions / GitLab CI (auto-detected)
	‚Ä¢	Local: local://user@host

No private keys are ever managed by the user.

‚∏ª

2. Attestation Policy
	‚Ä¢	Tool: Cosign
	‚Ä¢	Format: in-toto Statement v1
	‚Ä¢	Scope: Minimal, honest provenance

Included:
	‚Ä¢	Artifact digest
	‚Ä¢	Execution environment
	‚Ä¢	Source reference (if detectable)
	‚Ä¢	SBOM summary
	‚Ä¢	Vulnerability scan summary

Explicitly not claimed:
	‚Ä¢	SLSA L3/L4 compliance
	‚Ä¢	Code review or approval guarantees
	‚Ä¢	Hardened builder assertions

‚∏ª

3. SBOM Policy
	‚Ä¢	Enabled by default
	‚Ä¢	Tool: Syft (library mode)
	‚Ä¢	Format: CycloneDX JSON

SBOM is:
	‚Ä¢	Generated in-memory
	‚Ä¢	Never written as a standalone file
	‚Ä¢	Cryptographically bound into the attestation

This prevents TOCTOU-style replacement.

‚∏ª

4. Vulnerability Scan Policy (Default: ENABLED)
	‚Ä¢	Enabled by default
	‚Ä¢	Tool: Grype
	‚Ä¢	Mode: Observe

Behavior:
	‚Ä¢	Vulnerabilities are detected and recorded
	‚Ä¢	Severity counts are embedded in attestation
	‚Ä¢	Build is NOT blocked by findings

Vulnerabilities are treated as evidence gaps, not failures.

‚∏ª

5. License Checks
	‚Ä¢	‚ùå Not implemented in MVP
	‚Ä¢	‚ùå No implicit or explicit license enforcement

This is intentionally excluded to keep scope honest.

‚∏ª

6. Enforcement Mode
	‚Ä¢	Mode: Observer (fixed in zero-config)

Rules:
	‚Ä¢	Cryptographic failures ‚Üí exit 1
	‚Ä¢	Evidence gaps ‚Üí recorded, exit 0
	‚Ä¢	Infra failures ‚Üí degraded, exit 0

Provenix never blocks silently.

‚∏ª

7. Transparency Policy
	‚Ä¢	Rekor publish:
	‚Ä¢	CI: enabled by default
	‚Ä¢	Local: disabled by default

If Rekor is unavailable:
	‚Ä¢	Local attestation is still produced
	‚Ä¢	Failure is explicitly recorded

Evidence is never discarded.

‚∏ª

Configuration File (Optional, Opt-In)

Advanced users may provide provenix.yaml to:
	‚Ä¢	Enforce strict policies
	‚Ä¢	Declare SLSA intent
	‚Ä¢	Add organization-specific rules

Example:

version: 0.1
identity:
  strategy: keyless
  issuer: github

attestations:
  - type: provenance
  - type: vulnerability-scan
    on_failure: warn

enforcement:
  mode: strict

Providing a config only adds constraints ‚Äî it never weakens defaults.

‚∏ª

What Provenix Explicitly Does NOT Guarantee

Provenix is precise about its boundaries.

It does NOT guarantee:
	‚Ä¢	That source code was reviewed or approved
	‚Ä¢	That dependencies are authentic or trustworthy
	‚Ä¢	That the build environment is hardened
	‚Ä¢	That runtime behavior is secure

It guarantees only what it can prove.

‚∏ª

Failure Model (Atomic by Design)

Provenix classifies failures as:
	1.	Cryptographic Failure ‚Üí hard stop
	2.	Evidence Gap ‚Üí recorded, continue
	3.	Infrastructure Failure ‚Üí degraded, continue

Atomic Evidence succeeds when imperfection is explicit.

‚∏ª

Summary
	‚Ä¢	Zero-config is a first-class feature
	‚Ä¢	Default policies are safe, minimal, and honest
	‚Ä¢	Vulnerability scanning is enabled by default
	‚Ä¢	Attestations are always generated with Cosign
	‚Ä¢	Enforcement is explicit and opt-in

Provenix records reality. You decide what to enforce.