üõ°Ô∏è Provenix

The Policy-Driven Software Supply Chain Orchestrator

Provenix is an intent-first security orchestrator that generates atomic, cryptographically bound evidence for software artifacts. It abstracts tools like Cosign, Syft, and Grype into a single, policy-centric workflow‚Äîwithout forcing users to learn or operate those tools directly.

Provenix observes and records. It does not silently enforce.

‚∏ª

Core Concept: Atomic Evidence

Atomic Evidence means:

All evidence (SBOM, vulnerability results, provenance) is generated in a single execution context and cryptographically bound to the exact artifact digest at the moment of attestation.

It does not mean that all checks must pass.
‚Ä¢ Evidence may contain gaps
‚Ä¢ External publishing may partially fail
‚Ä¢ Integrity must never be broken

If atomicity is violated ‚Üí Provenix fails hard.

‚∏ª

Formal Definition of Atomic Evidence

Let E = (A, C, T, œÉ) represent evidence, where:
‚Ä¢ A: Artifact (digest: SHA256)
‚Ä¢ C: Context (SBOM, Vulnerabilities, Provenance)
‚Ä¢ T: Timestamp (execution time)
‚Ä¢ œÉ: Cryptographic signature

Atomicity Conditions:

1. ‚àÄc ‚àà C, hash(c) is included in œÉ
2. T is unique within a single execution session
3. Generation order of C is deterministic (SBOM ‚Üí Scan ‚Üí Attestation)
4. Digest of A is finalized before generating C

Non-Atomic Cases (Violations):

    ‚Ä¢	SBOM and Scan generated in separate processes
    ‚Ä¢	Artifact modified during evidence generation
    ‚Ä¢	Signature hash differs from SBOM generation hash

Implementation Guarantees:

    ‚Ä¢	Memory pipeline directly connects SBOM ‚Üí Grype (no intermediate files)
    ‚Ä¢	Artifact hash computed once at start, referenced thereafter
    ‚Ä¢	All components share the same execution_id
    ‚Ä¢	TOCTOU (Time-of-Check to Time-of-Use) attacks prevented by design

‚∏ª

Zero-Config First (MVP Philosophy)

Provenix is designed so that OSS maintainers can run it with zero configuration:

provenix attest <artifact>

No keys. No YAML. No CI glue code.

For local development without signing:

provenix attest <artifact> --local

Important Design Choice

When no configuration file is provided:

Provenix automatically generates an in-memory default policy.

This is not only acceptable ‚Äî it is recommended.
‚Ä¢ Users get safe, predictable behavior
‚Ä¢ Defaults are explicit and documented
‚Ä¢ Generated policy is shown in logs (--debug)

‚∏ª

Implicit Default Policy (Zero Config)

The following policies are implicitly applied when provenix.yaml is absent.

1. Identity Policy
   ‚Ä¢ Strategy: Keyless (OIDC)
   ‚Ä¢ Identity source:
   ‚Ä¢ CI: GitHub Actions / GitLab CI (auto-detected)
   ‚Ä¢ Local: local://user@host

No private keys are ever managed by the user.

‚∏ª

2. Attestation Policy
   ‚Ä¢ Tool: Cosign
   ‚Ä¢ Format: in-toto Statement v1
   ‚Ä¢ Scope: Minimal, honest provenance

Included:
‚Ä¢ Artifact digest
‚Ä¢ Execution environment
‚Ä¢ Source reference (if detectable)
‚Ä¢ SBOM summary
‚Ä¢ Vulnerability scan summary

Explicitly not claimed:
‚Ä¢ SLSA L3/L4 compliance
‚Ä¢ Code review or approval guarantees
‚Ä¢ Hardened builder assertions

‚∏ª

3. SBOM Policy
   ‚Ä¢ Enabled by default
   ‚Ä¢ Tool: Syft (library mode)
   ‚Ä¢ Format: CycloneDX JSON

SBOM is:
‚Ä¢ Generated in-memory
‚Ä¢ Never written as a standalone file
‚Ä¢ Cryptographically bound into the attestation

This prevents TOCTOU-style replacement.

‚∏ª

4. Vulnerability Scan Policy (Default: ENABLED)
   ‚Ä¢ Enabled by default
   ‚Ä¢ Tool: Grype
   ‚Ä¢ Mode: Observe

Behavior:
‚Ä¢ Vulnerabilities are detected and recorded
‚Ä¢ Severity counts are embedded in attestation
‚Ä¢ Build is NOT blocked by findings

Vulnerabilities are treated as evidence gaps, not failures.

‚∏ª

5. License Checks
   ‚Ä¢ ‚ùå Not implemented in MVP
   ‚Ä¢ ‚ùå No implicit or explicit license enforcement

This is intentionally excluded to keep scope honest.

‚∏ª

6. Enforcement Mode
   ‚Ä¢ Mode: Observer (fixed in zero-config)

Rules:
‚Ä¢ Cryptographic failures ‚Üí exit 1
‚Ä¢ Evidence gaps ‚Üí recorded, exit 0
‚Ä¢ Infra failures ‚Üí degraded, exit 0

Provenix never blocks silently.

‚∏ª

7. Transparency Policy
   ‚Ä¢ Rekor publish:
   ‚Ä¢ CI: enabled by default
   ‚Ä¢ Local: disabled by default

If Rekor is unavailable:
‚Ä¢ Local attestation is still produced
‚Ä¢ Failure is explicitly recorded

Evidence is never discarded.

‚∏ª

Configuration Philosophy

Provenix follows a **Progressive Configuration** model:

1. **Zero-Config (Default)**: Works out of the box with safe defaults
2. **Minimal Config**: Add constraints without managing complexity
3. **Full Control**: Enterprise-grade policy enforcement

**Configuration File Discovery:**

`provenix.yaml` is **completely optional**. When absent, Provenix uses safe built-in defaults.

Discovery order (project-scoped only):

1. `--config` flag
2. `PROVENIX_CONFIG` environment variable
3. `./provenix.yaml` (current directory)
4. `./.provenix/config.yaml` (local overrides, add to .gitignore)
5. Walk up to `.git` directory and check `provenix.yaml`
6. Built-in defaults (no config needed)

**Security boundary:** Provenix never searches outside your project directory (`~/.provenix/` or `/etc/provenix/` are NOT used).

**Recommended .gitignore:**

```
.provenix/config.yaml    # Personal settings (don't commit)
.provenix/cache/         # SBOM database cache
.provenix/attestations/  # Local attestations (regenerate in CI)
```

**Optional Setup Helper:**

```bash
# Generate template config (completely optional)
provenix init
```

‚∏ª

Configuration File (Optional, Opt-In)

Advanced users may provide provenix.yaml to:
‚Ä¢ Enforce strict policies
‚Ä¢ Declare SLSA intent
‚Ä¢ Add organization-specific rules

Example:

version: 0.1
identity:
strategy: keyless
issuer: github

attestations:

- type: provenance
- type: vulnerability-scan
  on_failure: warn

enforcement:
mode: strict

Providing a config only adds constraints ‚Äî it never weakens defaults.

‚∏ª

What Provenix Explicitly Does NOT Guarantee

Provenix is precise about its boundaries.

It does NOT guarantee:
‚Ä¢ That source code was reviewed or approved
‚Ä¢ That dependencies are authentic or trustworthy
‚Ä¢ That the build environment is hardened
‚Ä¢ That runtime behavior is secure

It guarantees only what it can prove.

‚∏ª

Failure Model (Atomic by Design)

Provenix classifies failures into three categories:

1. Cryptographic Failure ‚Üí Exit 1 (hard stop)

   - Signature verification failed
   - Hash mismatch between components
   - Attestation integrity violated

2. Evidence Gap ‚Üí Exit 2 (recorded, continue)

   - Vulnerabilities detected (observe mode)
   - Unsigned commits, dirty working tree
   - Missing optional checks

3. Infrastructure Failure ‚Üí Exit 2 (degraded, continue)
   - Rekor unreachable
   - Network timeout
   - Local attestation saved, publish incomplete

Exit Code Summary:
‚Ä¢ 0: Complete success (all evidence generated and published)
‚Ä¢ 1: Fatal failure (cryptographic or policy violation)
‚Ä¢ 2: Partial success (evidence generated, publishing failed)

Atomic Evidence succeeds when imperfection is explicit.

‚∏ª

Summary
‚Ä¢ Zero-config is a first-class feature
‚Ä¢ Default policies are safe, minimal, and honest
‚Ä¢ Vulnerability scanning is enabled by default
‚Ä¢ Attestations are always generated with Cosign
‚Ä¢ Enforcement is explicit and opt-in

Provenix records reality. You decide what to enforce.
